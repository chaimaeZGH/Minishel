//*******************//

// Check for pipes:
// in you start from the last and you found pipe then the pipe gona be rooth
// if not the cmd it self is the rooth and ther is no left right
// The right branch is the part after the last pipe ('|').
// The left branch is everything before the last pipe.




typedef struct s_tokenlist
{
	char			*content;
	struct s_tokenlist      	*prev;
	struct s_tokenlist      	*next;
	t_type_list		type;
}	                t_tokenlist;





typedef struct s_cmdlist
{
	int			here_doc_fd;
    char		**cmd;
    t_tokenlist	*args;
    t_tokenlist	*out;
    t_tokenlist	*in;
}			t_cmdlist;

typedef struct s_tree_list
{
	t_type_list			type;
	t_cmdlist			*cmd;
	struct s_tree_list	*right;
	struct s_tree_list	*left;
}						t_tree_list;




Recursive Tree Construction Logic
Input: A list of tokens (char **tokens, or a linked list, etc.).

Step 1: Search for the last pipe (|).

>> If you find one:

	Split the tokens into two parts:

	left = before last pipe

	right = after last pipe

	Create a node with command = "|".

	Recursively build left_subtree and right_subtree, and assign them to left and right.

>> If no pipe found:

	This is a single command.

	Create a node with command = full_command_string.

	Set left = NULL, right = NULL.



	t_tree_list *create_tree(t_tokenlist **head)
{
    t_tree_list *tree = NULL;
    if (head == NULL)
        return NULL;
    tree = malloc(sizeof(t_tree_list));
    if (tree == NULL)
        return NULL;
   
    tree->cmd = malloc(sizeof(t_cmdlist));
    if (!tree->cmd) 
    {
        free(tree);
        return NULL;
    }
	
    t_tokenlist *p_free;
    t_tokenlist *last_p = last_pipe(*head);
    if (last_p == NULL)
    {
        fill_tree(tree->cmd, *head);
        tree->right = NULL;
        tree->left = NULL;
        tree->type = comnd;
    }
    else
    {
        tree->type = PIPE;
        tree->cmd = NULL;
        last_p->prev->next = NULL;
        p_free=last_p;
        last_p = last_p->next;
        free_list(p_free);
        tree->right = create_tree(&last_p);
        tree->left = create_tree(head);
    }
    return (tree);
}